// permuto/include/permuto/permuto.hpp
#ifndef PERMUTO_PERMUTO_HPP
#define PERMUTO_PERMUTO_HPP

#include <nlohmann/json.hpp>
#include <string>
#include <stdexcept> // For runtime_error, logic_error

namespace permuto {

// Forward declaration from exceptions.hpp - include exceptions.hpp for use.
class PermutoException;
class PermutoCycleException;
class PermutoMissingKeyException;
class PermutoParseException;

/**
 * @brief Defines behavior when a variable or path cannot be resolved during apply().
 */
enum class MissingKeyBehavior {
    Ignore, ///< Leave the placeholder string as-is in the output.
    Error   ///< Throw a PermutoMissingKeyException.
};

/**
 * @brief Configuration options for the Permuto processing engine.
 */
struct Options {
    std::string variableStartMarker = "${";
    std::string variableEndMarker = "}";
    MissingKeyBehavior onMissingKey = MissingKeyBehavior::Ignore;
    bool enableStringInterpolation = false;

    /**
     * @brief Validates the options. Throws std::invalid_argument on failure.
     * Checks for empty delimiters or identical start/end delimiters.
     */
    void validate() const {
        if (variableStartMarker.empty()) {
            throw std::invalid_argument("variableStartMarker cannot be empty.");
        }
        if (variableEndMarker.empty()) {
            throw std::invalid_argument("variableEndMarker cannot be empty.");
        }
        if (variableStartMarker == variableEndMarker) {
            throw std::invalid_argument("variableStartMarker and variableEndMarker cannot be identical.");
        }
        // Future checks could go here (e.g., markers containing invalid chars?)
    }
};

/**
 * @brief Processes a JSON template by substituting variables from a context.
 *
 * Traverses the template JSON structure. When a string value is encountered,
 * it checks for placeholders defined by options.variableStartMarker and
 * options.variableEndMarker.
 * - If a string is an *exact match* for a placeholder (e.g., "${path.to.var}"),
 *   it's replaced by the corresponding value from the context, preserving the type
 *   (number, boolean, null, array, object, string). This happens regardless of
 *   the enableStringInterpolation setting.
 * - If `enableStringInterpolation` is true, placeholders within larger
 *   strings are substituted with their stringified representation. Non-string
 *   values are converted to compact JSON strings.
 * - If `enableStringInterpolation` is false (default), non-exact-match strings containing
 *   placeholders are treated as literals.
 *
 * Supports dot notation for nested access (e.g., "user.address.city"). Keys containing
 * literal dots (.), tildes (~), or slashes (/) are handled via JSON Pointer escaping.
 * Detects and throws on cyclical dependencies.
 *
 * @param template_json The input JSON template structure (must be valid JSON).
 * @param context The data context object used for variable lookups.
 * @param options Configuration for processing (delimiters, missing key behavior, interpolation).
 *                Defaults are used if not provided ({}, meaning interpolation OFF, ignore missing).
 * @return nlohmann::json The resulting JSON structure after substitutions.
 * @throws permuto::PermutoCycleException If a cyclical dependency is detected during lookup.
 * @throws permuto::PermutoMissingKeyException If a key/path is not found and options.onMissingKey is Error.
 * @throws std::invalid_argument If the provided Options are invalid (e.g., empty/identical delimiters).
 * @throws nlohmann::json::exception For JSON parsing or access errors within the context/template structure itself.
 */
nlohmann::json apply(
    const nlohmann::json& template_json,
    const nlohmann::json& context,
    const Options& options = {} // Default constructs Options
);


/**
 * @brief Creates a "reverse template" from an original template.
 *
 * This reverse template maps context variable paths (from exact-match placeholders
 * like "${var.path}" in the original template) to their location (JSON Pointer)
 * within the *result* JSON that would be generated by `apply()` *if string
 * interpolation were disabled*.
 *
 * **Requires `options.enableStringInterpolation` to be `false`.**
 *
 * Example:
 *   original_template = {"userName": "${user.name}", "data": ["${sys.id}"]}
 *   (with options.enableStringInterpolation = false)
 *   Resulting reverse_template =
 *     {"user": {"name": "/userName"}, "sys": {"id": "/data/0"}}
 *
 * @param original_template The original JSON template used for the `apply` operation.
 * @param options The *same* options structure used for the original `apply` call.
 *                Crucially, `enableStringInterpolation` must be `false`. Default options work.
 * @return nlohmann::json The generated reverse template.
 * @throws std::logic_error If `options.enableStringInterpolation` is `true`.
 * @throws std::invalid_argument If the provided Options are invalid (e.g., empty/identical delimiters).
 * @throws std::runtime_error If errors occur during processing, such as conflicting context paths.
 * @throws nlohmann::json::exception For issues traversing the original_template.
 */
nlohmann::json create_reverse_template(
    const nlohmann::json& original_template,
    const Options& options = {} // Default options are interp=false, ignore_missing
);

/**
 * @brief Reconstructs the original context data using a reverse template and result JSON.
 *
 * This function takes a `reverse_template` (generated by `create_reverse_template`)
 * and a `result_json` (the output of the original `apply` call, which MUST have
 * been generated with `enableStringInterpolation = false`) and reconstructs the
 * portion of the original context that was referenced by exact-match placeholders
 * in the original template.
 *
 * It traverses the `reverse_template`. When it finds a string value (which is
 * expected to be a JSON Pointer), it uses that pointer to look up the corresponding
 * value in `result_json` and places it in the reconstructed context according
 * to the structure defined by the `reverse_template`.
 *
 * Example:
 *   reverse_template = {"user": {"name": "/userName"}, "sys": {"id": "/data/0"}}
 *   result_json = {"userName": "Alice", "data": [123]}
 *   Resulting reconstructed_context = {"user": {"name": "Alice"}, "sys": {"id": 123}}
 *
 * @param reverse_template The reverse template generated by `create_reverse_template`.
 * @param result_json The result JSON generated by `apply()` with interpolation disabled.
 * @return nlohmann::json The reconstructed context data.
 * @throws std::runtime_error If the `reverse_template` contains invalid structure
 *         (e.g., non-object nodes where nesting is expected, non-string leaf nodes,
 *         invalid JSON pointer strings) or if a JSON pointer from the
 *         `reverse_template` cannot be resolved within `result_json`.
 * @throws nlohmann::json::exception For JSON parsing errors (e.g., invalid pointer syntax)
 *         or access errors (`out_of_range` if pointer lookup fails).
 */
nlohmann::json apply_reverse(
    const nlohmann::json& reverse_template,
    const nlohmann::json& result_json
);


} // namespace permuto

#endif // PERMUTO_PERMUTO_HPP
